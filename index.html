<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Lucky Horse Race — 직선·타원·샌드점프·스피닝더비</title>

<!-- SEO 기본 -->
<link rel="canonical" href="https://luckyhorserace.github.io/">
<meta name="robots" content="index,follow"/>
<meta name="description" content="말·기수 랜덤 추첨 게임! 직선 달리기(최대 1km), 타원 랩, 샌드 점프 피트, 스피닝 더비. 우승 오버레이와 리플레이 다운로드 지원."/>
<meta name="keywords" content="경마게임, 랜덤게임, 온라인 추첨, 사다리게임, 룰렛 대체, 내기게임, 파티게임"/>

<!-- OpenGraph / Twitter -->
<meta property="og:type" content="website"/>
<meta property="og:title" content="Lucky Horse Race — 랜덤 경마게임"/>
<meta property="og:description" content="직선·타원·샌드 점프·스피닝 더비! 우승자 발표와 리플레이 다운로드 지원."/>
<meta property="og:image" content="https://example.com/preview.png"/> <!-- 스크린샷 URL로 교체 -->
<meta property="og:url" content="https://luckyhorserace.github.io/"/>
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:title" content="Lucky Horse Race — 랜덤 경마게임"/>
<meta name="twitter:description" content="직선·타원·샌드 점프·스피닝 더비, 우승자 발표와 리플레이 다운로드 지원!"/>
<meta name="twitter:image" content="https://example.com/preview.png"/>

<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'/%3E">

<style>
:root{
  --bg:#0b1220; --panel:#0f172a; --ink:#e5e7eb; --muted:#94a3b8; --border:#1f2937;
  --accent:#6ee7ff; --accent2:#fcd34d; --ok:#22c55e; --danger:#ef4444;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0}
body{color:var(--ink);background:var(--bg);font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR","Malgun Gothic",sans-serif}

.wrap{position:relative;width:100vw;height:100vh;overflow:hidden}
.stage{position:absolute; inset:0;}
.viewport{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scale(1);transform-origin:50% 50%;transition:transform .12s ease-out}
.canvas{position:relative;width:min(98vw,1800px);height:auto;margin:0 auto}

/* 안내 배너 */
.notice{
  position:absolute; top:8px; left:12px; z-index:40;
  background:rgba(0,0,0,.45); padding:6px 12px; border-radius:10px;
  font-size:13px; color:#cbd5e1; backdrop-filter: blur(2px);
}

/* Maps */
svg{display:block}
.ovalSvg,.straightSvg,.arenaSvg{width:100%;height:auto}

/* Horses */
.horse{position:absolute;width:46px;height:34px;transform:translate(-50%,-50%);pointer-events:none; z-index:8}
.horse.jump{z-index:12}
.nameplate{position:absolute;bottom:100%;left:50%;transform:translate(-50%,-8px);background:#09111e;color:#dbe7f3;border:1px solid #2a3b57;border-radius:10px;font-size:11px;font-weight:800;padding:3px 8px;white-space:nowrap}
.horse-svg{width:46px;height:34px}
.horse-svg .body{fill:#e5e7eb}
.horse-svg .mane{fill:#cbd5e1}
.horse-svg .jockey{fill:var(--jersey,#60a5fa)}
.horse-svg .saddle{fill:#94a3b8}
.horse-svg .eye{fill:#0f172a}
@keyframes bob{0%,100%{transform:translateY(0)}50%{transform:translateY(-1.2px)}}
.horse-svg .g-bob{animation:bob .26s infinite ease-in-out}
@keyframes leg-run-front { 0%,100% { transform: rotate(18deg); } 50% { transform: rotate(-18deg); } }
@keyframes leg-run-back  { 0%,100% { transform: rotate(-18deg); } 50% { transform: rotate(18deg); } }
.front-leg{transform-origin: top center;animation: leg-run-front .42s infinite linear}
.back-leg {transform-origin: top center;animation: leg-run-back  .42s infinite linear}

/* Header/Controls */
header{position:absolute;inset:auto 0 0 0;padding:10px 12px;display:flex;align-items:flex-start;justify-content:space-between;gap:12px;background:rgba(0,0,0,.5);z-index:30;flex-wrap:wrap}
.group{display:flex;gap:8px;align-items:center;flex-wrap:wrap;background:rgba(255,255,255,.04);border:1px solid #2a3b57;border-radius:12px;padding:8px}
.group h4{margin:0 6px 0 0;font-size:12px;color:#93c5fd;opacity:.9}
button{border:0;border-radius:12px;padding:10px 14px;cursor:pointer;font-weight:800;letter-spacing:.2px}
.btn-accent{background:linear-gradient(180deg,#1b9ab7,#168aa4);color:#06131b;border:1px solid #0a6c82}
.btn-ghost{background:rgba(0,0,0,.35);border:1px solid #2a3a57;color:#cbd5e1}
.btn-accent:hover,.btn-ghost:hover{filter:brightness(1.06)}
input[type="text"],select,input[type="number"]{padding:10px;border:1px solid #223047;border-radius:10px;background:rgba(0,0,0,.35);color:#dbe7f3}
#names{min-width:260px}

/* Ranking: 10명 단위 열, 오른쪽에 새 열이 붙고 기존 열이 왼쪽으로 밀림 */
.rankWrap{position:absolute;top:12px;right:12px;z-index:25;display:flex;gap:8px;align-items:flex-start;flex-direction:row-reverse}
.ranking{width:260px;background:rgba(8,18,34,.78);border:1px solid #2a3b54;border-radius:10px;padding:8px;font-size:13px}
.ranking h3{margin:2px 0 6px;font-size:13px;color:#93c5fd}
.ranking .row{display:flex;justify-content:space-between;padding:2px 6px;border-radius:6px}
.ranking .row:nth-child(odd){background:rgba(255,255,255,.03)}
.ranking .pos{font-weight:900;color:#6ee7ff}
.color-badge{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle;border:1px solid #1f2937}

/* HUD (큰 카운트다운) */
.hud{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:20}
.hud.show{display:flex}
.traffic{display:flex;gap:14px;align-items:center;background:#0b1220cc;border:1px solid #334155;padding:14px 18px;border-radius:14px}
.light{width:22px;height:22px;border-radius:50%;background:#111827;border:1px solid #334155}
.light.on.red{background:#ef4444}.light.on.yellow{background:#f59e0b}.light.on.green{background:#22c55e}
.countTxt{margin-left:6px;font-weight:900;font-size:clamp(24px,5vw,36px)}
.gun{margin-left:8px;font-size:clamp(16px,3.2vw,20px);color:#93c5fd}

/* 우승 오버레이 */
#celebrate{position:fixed;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;background:rgba(0,0,0,.55);z-index:10000;text-align:center}
#winnerVisual{font-size:96px;display:flex;gap:16px;align-items:center;justify-content:center;margin-bottom:8px}
#celeTitle{font-size:72px;color:#fff;margin:0 0 8px;letter-spacing:.2em;animation:jelly 1.6s ease both; text-shadow:0 2px 10px rgba(0,0,0,.45),0 0 22px rgba(110,231,255,.25)}
#celeSubtitle{font-size:28px;color:#e6f9ff;margin:0 18px 18px;text-shadow:0 1px 6px rgba(0,0,0,.35)}
@keyframes jelly{0%{transform:scale(0.8)}40%{transform:scale(1.12)}60%{transform:scale(0.98)}100%{transform:scale(1)}}
.winnerCard{display:flex;gap:20px;align-items:center;justify-content:center;margin:8px 0 18px}
.winnerHorse{width:160px;height:120px;transform:scale(1.2)}
.winnerName{font-size:28px;font-weight:900}

/* 모바일 보정 */
@media (max-width:640px){.ranking{width:220px}#names{min-width:180px}}
</style>
</head>
<body>
<div class="wrap">

  <!-- 좌측 상단 안내 -->
  <div class="notice">자유롭게 사용해주시고 피드백 부탁드려요 🙏</div>

  <!-- HUD -->
  <div class="hud" id="hud">
    <div class="traffic">
      <div class="light" id="ltR"></div>
      <div class="light" id="ltY"></div>
      <div class="light" id="ltG"></div>
      <span class="countTxt" id="countTxt">Ready</span>
      <span class="gun" id="gunTxt"></span>
    </div>
  </div>

  <!-- Stage -->
  <div class="stage" id="stage">
    <div class="viewport" id="viewport">
      <div class="canvas" id="canvas">
        <!-- 타원 -->
        <svg id="ovalMap" class="ovalSvg" viewBox="0 0 1000 600" style="display:none"></svg>
        <!-- 직선 -->
        <svg id="straightMap" class="straightSvg" viewBox="0 0 2000 400" style="display:none"></svg>
        <!-- 샌드 점프 -->
        <svg id="sandMap" class="straightSvg" viewBox="0 0 2000 500" style="display:none"></svg>
        <!-- 아레나(스피닝 더비) -->
        <svg id="arenaMap" class="arenaSvg" viewBox="0 0 800 800" style="display:none"></svg>
      </div>
    </div>

    <!-- 순위판 (열 분할 컨테이너) -->
    <div class="rankWrap" id="rankWrap"></div>
  </div>

  <!-- 하단 UI -->
  <header>
    <!-- 경기 제어 -->
    <div class="group" id="controlGroup">
      <h4>경기 제어</h4>
      <input id="names" type="text" placeholder="참가자 입력 (예: 고구마 감자 김치 / 고구마*3)">
      <select id="mapSelect" title="맵 선택">
        <option value="straight">직선</option>
        <option value="oval">타원</option>
        <option value="sand">샌드 점프</option>
        <option value="arena">스피닝 더비</option>
      </select>

      <!-- 맵별 옵션 -->
      <select id="raceDist" title="거리(직선 전용)">
        <option value="100">100m</option>
        <option value="200">200m</option>
        <option value="300">300m</option>
        <option value="1000">1000m</option>
      </select>
      <select id="raceLen" title="랩 수(타원 전용)" style="display:none">
        <option value="1">1바퀴</option>
        <option value="3" selected>3바퀴</option>
        <option value="5">5바퀴</option>
        <option value="10">10바퀴</option>
      </select>
      <select id="sandPit" title="모래 피트 길이(샌드 점프 전용)" style="display:none">
        <option value="30">30m 피트</option>
        <option value="50" selected>50m 피트</option>
        <option value="80">80m 피트</option>
      </select>

      <button class="btn-accent" id="startBtn">시작 ▶</button>
      <button class="btn-ghost" id="resetBtn">리셋</button>
      <button class="btn-ghost" id="leaderViewBtn">리더뷰: ON</button>
      <button class="btn-ghost" id="fullscreenBtn">전체화면</button>
    </div>

    <!-- 추첨 규칙 (카메라와 분리) -->
    <div class="group" id="drawGroup">
      <h4>추첨 규칙</h4>
      <label class="seg-item on" data-type="first"><input type="radio" name="draw" value="first" checked> 1등</label>
      <label class="seg-item" data-type="last"><input type="radio" name="draw" value="last"> 마지막</label>
      <label class="seg-item" data-type="nth"><input type="radio" name="draw" value="nth"> n등</label>
      <input id="drawNthInput" type="number" min="1" step="1" placeholder="n등" disabled>
    </div>

    <!-- 지원/문의 -->
    <div class="group">
      <h4>지원</h4>
      <a class="btn-accent" href="https://buymeacoffee.com/luckyhorse" target="_blank" rel="noopener">개발자에게 라면 사주기 🍜</a>
      <button class="btn-ghost" id="btnContact">문의·피드백</button>
    </div>
  </header>
</div>

<!-- 우승 오버레이 -->
<div id="celebrate">
  <div id="winnerVisual">👑 🥕 ✨</div>
  <div id="celeTitle">W i n n e r r r r r ~</div>
  <div id="celeSubtitle">이 맛에 달린다~</div>
  <div class="winnerCard" id="winnerCard"></div>
  <div style="display:flex; gap:8px">
    <button class="btn-accent" id="replaySaveBtn">리플레이 다운로드</button>
    <button class="btn-ghost" onclick="document.getElementById('celebrate').style.display='none'">닫기</button>
  </div>
</div>

<script>
/* ====== Utils ====== */
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
let _rand=Math.random;
function reseed(seed){_rand=mulberry32(seed|0)}
function autoSeed(){return(Date.now()^Math.floor(Math.random()*0xFFFFFFFF))>>>0}
const JERSEYS=['#60a5fa','#22c55e','#f59e0b','#ef4444','#a855f7','#14b8a6','#eab308','#fb7185','#34d399','#f97316','#a3e635','#e879f9','#f43f5e','#6ee7ff'];
function jc(i){return JERSEYS[i%JERSEYS.length]}
function splitNames(raw){
  return raw.split(/[/\s]+/).map(s=>s.trim()).filter(Boolean)
    .flatMap(s=>{const m=s.match(/(.+)\*(\d+)/);return m?Array.from({length:Math.min(50,parseInt(m[2]))},()=>m[1]):s})
    .slice(0,50).map((n,i)=>({name:n,no:i+1}));
}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function download(filename, text){
  const a=document.createElement('a');
  a.href='data:application/json;charset=utf-8,'+encodeURIComponent(text);
  a.download=filename; a.click();
}

/* ====== DOM ====== */
const $names=document.getElementById('names'),
      $mapSel=document.getElementById('mapSelect'),
      $raceLen=document.getElementById('raceLen'),
      $raceDist=document.getElementById('raceDist'),
      $sandPit=document.getElementById('sandPit'),
      $start=document.getElementById('startBtn'),
      $reset=document.getElementById('resetBtn'),
      $leaderBtn=document.getElementById('leaderViewBtn'),
      $fullscreenBtn=document.getElementById('fullscreenBtn'),
      $rankWrap=document.getElementById('rankWrap'),
      $viewport=document.getElementById('viewport'),
      $canvas=document.getElementById('canvas'),
      $ovalMap=document.getElementById('ovalMap'),
      $straightMap=document.getElementById('straightMap'),
      $sandMap=document.getElementById('sandMap'),
      $arenaMap=document.getElementById('arenaMap'),
      $cele=document.getElementById('celebrate'),
      $winnerCard=document.getElementById('winnerCard'),
      $replaySaveBtn=document.getElementById('replaySaveBtn');

/* ====== State ====== */
const MIN=2,MAX=50;
let H=[],running=false,raf=null;
let laps=3, dist=100, pitLen=50;
let mapMode="straight"; // straight | oval | sand | arena
let pendingDraw={type:'first'};
let finishOrder = [];
let entryDone = new Map();
let drawFired = false;
let leaderView=true;
let camPanX=0;
let seed=autoSeed();

/* ====== Replay ====== */
let replay={meta:{}, events:[]};
function logEv(t, type, data){ replay.events.push({t, type, data}); }
function resetFinishOrder(){ finishOrder=[]; entryDone.clear(); drawFired=false; }

/* ====== Dynamic sizing ====== */
let straightViewW = 2000, straightViewH = 400;
function dynamicTrackHeight(){
  const n=Math.max(2, H.length||splitNames($names.value).length||2);
  return Math.min(260, 90 + n*9);
}

/* ====== SVG drawing ====== */
function drawStraight(){
  straightViewW = 20*dist;
  straightViewH = 400;
  const dynH = dynamicTrackHeight();
  const dynY = Math.round((straightViewH - dynH)/2);
  const startX=80, finishX=straightViewW-80;

  $straightMap.setAttribute('viewBox',`0 0 ${straightViewW} ${straightViewH}`);
  $straightMap.innerHTML = `
    <rect x="0" y="${dynY}" width="${straightViewW}" height="${dynH}" fill="#0e1a2a" stroke="#2a3b54" stroke-width="2"/>
    <line x1="${startX}" y1="${dynY-12}" x2="${startX}" y2="${dynY+dynH+12}" stroke="#22d3ee" stroke-width="6"/>
    <text x="${startX}" y="${dynY-20}" text-anchor="middle" font-size="14" fill="#a5f3fc" font-weight="800">출발</text>
    <line x1="${finishX}" y1="${dynY-16}" x2="${finishX}" y2="${dynY+dynH+16}" stroke="#ffffff" stroke-width="8"/>
    <text x="${finishX}" y="${dynY-20}" text-anchor="middle" font-size="14" fill="#e5e7eb" font-weight="900">도착</text>
  `;
}
function drawOval(){
  const rx=420, ryBase=220;
  $ovalMap.setAttribute('viewBox','0 0 1000 600');
  $ovalMap.innerHTML = `
    <ellipse cx="500" cy="300" rx="${rx}" ry="${ryBase}" fill="#0e1a2a" stroke="#2a3b54" stroke-width="2"/>
    <ellipse cx="500" cy="300" rx="${rx-60}" ry="${ryBase-60}" fill="#0b1220" stroke="#1f2937" stroke-width="2"/>
    <ellipse cx="500" cy="300" rx="${rx-30}" ry="${ryBase-30}" fill="none" stroke="#5b708f" stroke-dasharray="6,6" stroke-width="2"/>
    <text x="500" y="70" text-anchor="middle" font-size="14" fill="#a5f3fc" font-weight="800">출발/피니시</text>
  `;
}
function drawSand(){
  const W=20*dist, H=500;
  $sandMap.setAttribute('viewBox',`0 0 ${W} ${H}`);
  const top=120, bot=380, mid=(top+bot)/2;
  const takeoffX = Math.round(W*0.4);
  const pitStartX = takeoffX;
  const pitEndX   = Math.min(W-80, pitStartX + pitLen*20);

  $sandMap.innerHTML = `
    <rect x="0" y="${mid}" width="${pitStartX-0}" height="${bot-mid+60}" fill="#0e1a2a" stroke="#2a3b54" stroke-width="2"/>
    <rect x="${pitStartX}" y="${mid}" width="${Math.max(1,pitEndX-pitStartX)}" height="${bot-mid+60}" fill="#5a4125" stroke="#3a2b18" stroke-width="2"/>
    <line x1="80" y1="${mid-10}" x2="80" y2="${bot+60}" stroke="#22d3ee" stroke-width="6"/>
    <text x="80" y="${mid-16}" text-anchor="middle" font-size="14" fill="#a5f3fc" font-weight="800">출발</text>
    <line x1="${takeoffX}" y1="${mid-10}" x2="${takeoffX}" y2="${bot+60}" stroke="#fcd34d" stroke-width="6"/>
    <text x="${takeoffX}" y="${mid-16}" text-anchor="middle" font-size="14" fill="#fde68a" font-weight="900">도약선</text>
  `;
}
function drawArena(){
  const W=800,H=800, cx=W/2, cy=H/2, r=320;
  $arenaMap.setAttribute('viewBox','0 0 800 800');
  $arenaMap.innerHTML = `
    <defs>
      <radialGradient id="g" cx="50%" cy="50%"><stop offset="0%" stop-color="#0b1628"/><stop offset="100%" stop-color="#09111e"/></radialGradient>
    </defs>
    <rect x="0" y="0" width="${W}" height="${H}" fill="url(#g)" stroke="#2a3b54"/>
    <circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="#2a3b54" stroke-width="3"/>
    <circle cx="${cx}" cy="${cy}" r="${r-60}" fill="none" stroke="#1e2a45" stroke-dasharray="8,8" stroke-width="2"/>
  `;
}

/* ====== Horses ====== */
function horseSVG(color){return `<svg class="horse-svg" viewBox="0 0 64 44" xmlns="http://www.w3.org/2000/svg" style="--jersey:${color}">
  <g class="g-bob">
    <path class="mane" d="M10 26c2-3 3-5 6-6 0 4-2 7-4 9l-4-1 2-2z"/>
    <path class="body" d="M8 28c7-9 12-11 20-11h9c7 0 14 4 19 9l3 5-4 2-6-4-7 2H28l-8 1-6 3-6-1 6-6z"/>
    <rect class="saddle" x="28" y="17" width="11" height="7" rx="2"/>
    <g class="jockey"><circle cx="31" cy="12" r="3.6"/><rect x="28" y="15.5" width="10" height="7" rx="2"/></g>
    <circle class="eye" cx="22.5" cy="20.5" r="0.9"/>
    <rect class="front-leg" x="21" y="26" width="3.5" height="13" fill="#e5e7eb"/>
    <rect class="back-leg"  x="36" y="26" width="3.5" height="13" fill="#e5e7eb"/>
  </g>
</svg>`}
function winnerHorseSVG(color){return `<svg class="winnerHorse" viewBox="0 0 64 44" xmlns="http://www.w3.org/2000/svg" style="--jersey:${color}">
  <g>
    <path fill="#cbd5e1" d="M10 26c2-3 3-5 6-6 0 4-2 7-4 9l-4-1 2-2z"/>
    <path fill="#e5e7eb" d="M8 28c7-9 12-11 20-11h9c7 0 14 4 19 9l3 5-4 2-6-4-7 2H28l-8 1-6 3-6-1 6-6z"/>
    <rect fill="#94a3b8" x="28" y="17" width="11" height="7" rx="2"/>
    <g class="jockey"><circle cx="31" cy="10.8" r="3.6" fill="${color}"/><rect x="28" y="14.8" width="10" height="7" rx="2" fill="${color}"/></g>
    <circle cx="22.5" cy="20.5" r="0.9" fill="#0f172a"/>
    <rect x="36" y="18" width="3.5" height="13" fill="#e5e7eb" transform="rotate(-25 37.75 24.5)"/>
    <rect x="21" y="22" width="3.5" height="13" fill="#e5e7eb" transform="rotate(15 22.75 28.5)"/>
    <g transform="translate(44,10)">
      <path d="M0 4h10v6a5 5 0 0 1-10 0z" fill="#facc15" stroke="#a16207"/>
      <rect x="3" y="10" width="4" height="5" rx="1" fill="#d97706"/>
      <rect x="2" y="14" width="6" height="3" rx="1" fill="#92400e"/>
    </g>
    <g transform="translate(18,8)">
      <path d="M0 4h10v6a5 5 0 0 1-10 0z" fill="#facc15" stroke="#a16207"/>
      <rect x="3" y="10" width="4" height="5" rx="1" fill="#d97706"/>
      <rect x="2" y="14" width="6" height="3" rx="1" fill="#92400e"/>
    </g>
  </g>
</svg>`}

/* ====== Helpers ====== */
function clearHorses(){ $canvas.querySelectorAll('.horse').forEach(n=>n.remove()); H.length=0; }
function placeHorseStraight(h){
  const vb = $straightMap.getAttribute('viewBox').split(' ').map(Number);
  const W=vb[2], Hvb=vb[3];
  const rect=$straightMap.getBoundingClientRect();
  const scaleX=rect.width/W, scaleY=rect.height/Hvb;

  const dynH = dynamicTrackHeight();
  const dynY = Math.round((Hvb - dynH)/2);
  const startX=80, finishX=W-80;

  const progress = clamp(h.x/dist, 0, 1);
  const sx = startX + (finishX-startX)*progress;

  const lanes = H.length;
  const laneGap = Math.min(28, dynH/Math.max(1,lanes));
  const cy = dynY + dynH/2 + (h.laneIdx-(lanes-1)/2) * laneGap;

  let x=sx*scaleX, y=cy*scaleY;

  if(h.jumping){
    const p = Math.min(1, h.jumpT / h.jumpDur);
    const arc = Math.sin(Math.PI * p);
    y -= 26 * arc;
  }
  h.$el.style.left = x+'px'; h.$el.style.top = y+'px';
  h.$el.style.transform=`translate(-50%,-50%)`;

  const dur = Math.max(0.18, 0.6 - (h.speed*0.12));
  if(Math.abs(dur - (h.legsDur||0.42)) > 0.01){
    h.legsDur = dur;
    h.$el.querySelectorAll('.front-leg,.back-leg').forEach(e=>e.style.animationDuration = dur+'s');
  }
}
function placeHorseSand(h){
  const vb = $sandMap.getAttribute('viewBox').split(' ').map(Number);
  const W=vb[2], Hvb=vb[3];
  const rect=$sandMap.getBoundingClientRect();
  const scaleX=rect.width/W, scaleY=rect.height/Hvb;

  const lanes = H.length;
  const laneGap = Math.min(28, 140/Math.max(1,lanes));
  const baseY = 260 + (h.laneIdx-(lanes-1)/2) * laneGap;

  const startX=80;
  const sx = startX + (W-160)*(h.x/dist);

  let x=sx*scaleX, y=baseY*scaleY;

  if(h.air){
    const p = clamp(h.airT/h.airDur,0,1);
    const arc = Math.sin(Math.PI*p);
    y -= 26 * arc;
  }
  h.$el.style.left = x+'px'; h.$el.style.top = y+'px';
  h.$el.style.transform=`translate(-50%,-50%)`;

  const dur = Math.max(0.18, 0.6 - (h.speed*0.12));
  if(Math.abs(dur - (h.legsDur||0.42)) > 0.01){
    h.legsDur = dur;
    h.$el.querySelectorAll('.front-leg,.back-leg').forEach(e=>e.style.animationDuration = dur+'s');
  }
}
function placeHorseOval(h){
  const rect=$ovalMap.getBoundingClientRect();
  const rx=420, ry=220, cx=500, cy=300;

  const angle = -Math.PI/2 + (h.lapProg%1) * Math.PI*2 + h.thetaOffset;
  const nx = Math.cos(angle)/Math.hypot(Math.cos(angle)/rx, Math.sin(angle)/ry);
  const ny = Math.sin(angle)/Math.hypot(Math.cos(angle)/rx, Math.sin(angle)/ry);
  const laneOffset = (h.laneIdx - (H.length-1)/2) * 12;

  const px = cx + (rx * Math.cos(angle)) + nx*laneOffset;
  const py = cy + (ry * Math.sin(angle)) + ny*laneOffset;

  const scaleX=rect.width/1000, scaleY=rect.height/600;
  const x = px*scaleX, y = py*scaleY;

  h.$el.style.left = x+'px'; h.$el.style.top = y+'px';
  h.$el.style.transform=`translate(-50%,-50%)`;

  const dur = Math.max(0.18, 0.6 - (h.speed*0.12));
  if(Math.abs(dur - (h.legsDur||0.42)) > 0.01){
    h.legsDur = dur;
    h.$el.querySelectorAll('.front-leg,.back-leg').forEach(e=>e.style.animationDuration = dur+'s');
  }
}
function placeHorseArena(h){
  const vb=$arenaMap.getAttribute('viewBox').split(' ').map(Number);
  const W=vb[2], H=vb[3];
  const rect=$arenaMap.getBoundingClientRect();
  const scaleX=rect.width/W, scaleY=rect.height/H;

  const x = h.ax*scaleX, y=h.ay*scaleY;
  h.$el.style.left=x+'px'; h.$el.style.top=y+'px';
  h.$el.style.transform=`translate(-50%,-50%) rotate(${h.rot||0}deg)`;
}

/* ====== Build horses ====== */
function clearCanvas(){ $canvas.querySelectorAll('.horse').forEach(n=>n.remove()); H.length=0; }
function buildHorses(list){
  clearCanvas();
  list.forEach((ent,i)=>{
    const color = jc(i);
    const el=document.createElement('div');
    el.className='horse';
    el.innerHTML=horseSVG(color);
    const plate=document.createElement('div');
    plate.className='nameplate';
    plate.textContent=`${ent.no}번 ${ent.name}`;
    plate.style.borderColor = color;
    plate.style.boxShadow = `0 0 0 1px rgba(0,0,0,.25), 0 0 8px 0 ${color}33`;
    el.appendChild(plate);
    $canvas.appendChild(el);

    if(mapMode==='straight'){
      const base   = 2.8 + _rand()*(6.2-2.8);
      H.push({
        entryId:i, laneIdx:i, name:ent.name,no:ent.no,color,$el:el,
        x:0, base, speed: base*(0.85+_rand()*0.3), fatigue:0, legsDur:.42,
        jumping:false,jumpT:0,jumpDur:0.55, done:false,_finished:false
      });
    }else if(mapMode==='sand'){
      const base   = 2.8 + _rand()*(6.2-2.8);
      const jumpPow = 0.6 + _rand()*1.4; // 점프 성능(달리기와 독립)
      H.push({
        entryId:i, laneIdx:i, name:ent.name,no:ent.no,color,$el:el,
        x:0, base, speed: base*(0.85+_rand()*0.3), fatigue:0, legsDur:.42,
        air:false, airT:0, airDur:(0.5+_rand()*0.5), jumpPow, landed:false, landX:0,
        done:false,_finished:false
      });
    }else if(mapMode==='oval'){
      H.push({
        entryId:i, laneIdx:i, name:ent.name,no:ent.no,color,$el:el,
        lapProg:0, speed: 4.3 + _rand()*1.6, thetaOffset:(i-(list.length-1)/2)*0.06,
        done:false,_finished:false
      });
    }else if(mapMode==='arena'){
      const vb=$arenaMap.getAttribute('viewBox').split(' ').map(Number);
      const W=vb[2], Hvb=vb[3], cx=W/2, cy=Hvb/2;
      const r=60;
      const ax=cx + (_rand()-0.5)*r, ay=cy + (_rand()-0.5)*r;
      H.push({
        entryId:i, laneIdx:i, name:ent.name,no:ent.no,color,$el:el,
        ax, ay, vx:(_rand()-0.5)*2.0, vy:(_rand()-0.5)*2.0, rot:_rand()*360,
        done:false,_finished:false
      });
    }
  });

  updateRanking();
  H.forEach(placeEntity);
}

/* ====== Placement multiplexer ====== */
function placeEntity(h){
  if(mapMode==='straight') return placeHorseStraight(h);
  if(mapMode==='sand') return placeHorseSand(h);
  if(mapMode==='oval') return placeHorseOval(h);
  if(mapMode==='arena') return placeHorseArena(h);
}

/* ====== Ranking (열 분할) ====== */
function toEntryOrder(){
  if(mapMode==='oval'){
    const best = new Map();
    H.forEach(h=>{
      const p = Math.min(h.lapProg, laps);
      if(!best.has(h.entryId) || best.get(h.entryId)._p < p) best.set(h.entryId, {...h, _p:p});
    });
    return [...best.values()].sort((a,b)=> b._p - a._p);
  }else if(mapMode==='sand'){
    const landed = H.filter(h=>h.landed).slice().sort((a,b)=> b.landX - a.landX);
    const rest   = H.filter(h=>!h.landed).slice().sort((a,b)=> b.x - a.x);
    return landed.concat(rest);
  }else if(mapMode==='arena'){
    const finished = finishOrder.slice();
    const rest = H.filter(h=>!h.done).slice().sort((a,b)=>{
      const vb=$arenaMap.getAttribute('viewBox').split(' ').map(Number);
      const W=vb[2],Hvb=vb[3],cx=W/2,cy=Hvb/2;
      const da=Math.hypot(a.ax-cx,a.ay-cy), db=Math.hypot(b.ax-cx,b.ay-cy);
      return da-db;
    });
    return finished.concat(rest);
  }else{
    const finished = finishOrder.slice();
    const rest = H.filter(h=>!h.done).slice().sort((a,b)=> Math.min(b.x,dist) - Math.min(a.x,dist));
    return finished.concat(rest);
  }
}
function renderRankColumns(list){
  $rankWrap.innerHTML='';
  const cols = Math.ceil(list.length/10)||1;
  for(let c=0;c<cols;c++){
    const box=document.createElement('div');
    box.className='ranking';
    box.innerHTML=`<h3>현재 순위</h3><div class="lines"></div>`;
    const lines=box.querySelector('.lines');
    const slice=list.slice(c*10,(c+1)*10);
    lines.innerHTML=slice.map((h,i)=>{
      const pos=c*10+i+1;
      let status='';
      if(mapMode==='oval') status = h.done?'완주':`${(h.lapProg).toFixed(2)}랩`;
      else if(mapMode==='sand') status = h.landed?`${(h.landX).toFixed(1)}m`:`${Math.floor(h.x)}m`;
      else if(mapMode==='arena') status = h.done?'탈락':'생존';
      else status = h.done?'완주':`${Math.floor(h.x)}m`;
      return `<div class="row"><span class="pos">${pos}위</span>
      <span><span class="color-badge" style="background:${h.color}"></span>${h.no}번 ${h.name} - ${status}</span></div>`;
    }).join('');
    $rankWrap.appendChild(box);
  }
}
function updateRanking(){ renderRankColumns(toEntryOrder()); }

/* ====== Camera (리더뷰) ====== */
function updateCamera(){
  if(!leaderView){
    $viewport.style.transform = `translate(-50%,-50%) scale(1)`;
    return;
  }
  const order = toEntryOrder();
  const lead = order[0];
  if(!lead){ $viewport.style.transform = `translate(-50%,-50%) scale(1)`; return; }

  const activeView = (mapMode==='straight')?$straightMap:(mapMode==='sand')?$sandMap:(mapMode==='oval')?$ovalMap:$arenaMap;
  const rect = activeView.getBoundingClientRect();
  const scale = (mapMode==='arena')? 1.08 : 1.24;
  const leadX = lead.$el?.offsetLeft || rect.width/2;

  const finished = (mapMode==='oval') ? (lead.lapProg>=laps-1e-6) :
                   (mapMode==='sand') ? H.every(h=>h.landed) :
                   (mapMode==='arena') ? (H.filter(h=>!h.done).length<=1) :
                   (lead.x>=dist-1e-6);
  if(finished){
    $viewport.style.transform = `translate(-50%,-50%) scale(${scale}) translate(${camPanX}px, 0)`;
    return;
  }
  const targetPanX = clamp((rect.width/2 - leadX)/scale, -rect.width*0.35, rect.width*0.35);
  camPanX += (targetPanX - camPanX) * 0.15;
  $viewport.style.transform = `translate(-50%,-50%) scale(${scale}) translate(${camPanX}px, 0)`;
}

/* ====== Countdown HUD ====== */
const $hud=document.getElementById('hud'),
      $ltR=document.getElementById('ltR'),
      $ltY=document.getElementById('ltY'),
      $ltG=document.getElementById('ltG'),
      $countTxt=document.getElementById('countTxt'),
      $gunTxt=document.getElementById('gunTxt');
function wait(ms){return new Promise(r=>setTimeout(r,ms))}
async function countdown(){
  $hud.classList.add('show');
  $ltR.className='light on red'; $countTxt.textContent='3'; await wait(650);
  $ltY.className='light on yellow'; $countTxt.textContent='2'; await wait(650);
  $ltG.className='light on green'; $countTxt.textContent='1'; await wait(550);
  $countTxt.textContent='출발!'; $gunTxt.textContent='탕!'; await wait(300);
  $hud.classList.remove('show'); $gunTxt.textContent='';
}

/* ====== Winner ====== */
function showWinner(entry, extraText){
  $cele.style.display='flex';
  $winnerCard.innerHTML = `
    <div>${winnerHorseSVG(entry.color)}</div>
    <div class="winnerName">[${entry.no}] ${entry.name}${extraText?` — ${extraText}`:''}</div>
  `;
  replay.meta.finishedAt = Date.now();
  $replaySaveBtn.onclick = ()=>{ download('lucky-horse-replay.json', JSON.stringify(replay,null,2)); };
}

/* ====== Draw trigger ====== */
function maybeFireDraw(){
  if(drawFired || !pendingDraw) return;
  const k = finishOrder.length; if(k===0) return;

  function pick(n){return finishOrder[n-1];}
  let target=null;

  if(pendingDraw.type==='first' && k>=1){ target=pick(1); }
  if(pendingDraw.type==='nth'){
    const n=Math.max(1,parseInt(pendingDraw.n||1,10)); if(k>=n) target=pick(n);
  }
  if(pendingDraw.type==='last'){
    if(k===toEntryOrder().length){ target=pick(k); }
  }
  if(target){
    drawFired=true; pendingDraw=null;
    let add='';
    if(mapMode==='sand' && target.landX!=null) add=`${Number(target.landX).toFixed(1)}m`;
    if(mapMode==='arena') add='최후 생존자';
    showWinner(target, add);
  }
}

/* ====== Finish 기록 ====== */
function finishEntry(h){
  if(entryDone.get(h.entryId)) return;
  entryDone.set(h.entryId, true);
  const entry = {entryId:h.entryId, name:h.name, no:h.no, color:h.color, landX:h.landX};
  finishOrder.push(entry);
  logEv((performance.now()-startTS)/1000,'finish', entry);
  maybeFireDraw();
}

/* ====== Physics params ====== */
const JITTER_FACTOR   = 0.22;
const BOOST_PROB      = 0.015;
const BOOST_GAIN      = 0.75;
const FATIGUE_INC     = 0.14;
const FATIGUE_DEC     = 0.07;
const FATIGUE_PENALTY = 0.16;
const VMIN_RATIO      = 0.55;
const VMAX_RATIO      = 2.10;

/* ====== Race Loop ====== */
let lastTime=null, startTS=0;
function run(){
  running=true; lastTime=null; startTS=performance.now();

  const tick=(now)=>{
    if(lastTime===null) lastTime=now;
    const dt=Math.max(0.001,Math.min(0.05,(now-lastTime)/1000));
    lastTime=now;

    if(mapMode==='oval'){
      for(const h of H){
        if(h.done) continue;
        h.lapProg += h.speed * dt * (1.34)/100; // 타원 보정
        if(h.lapProg>=laps){ h.lapProg=laps; h.done=true; }
        if(!h._finished && h.done){ h._finished=true; finishEntry(h); }
        placeHorseOval(h);
      }
    }else if(mapMode==='straight'){
      for(const h of H){
        if(h.done) continue;
        h.speed += h.base*JITTER_FACTOR*(_rand()-0.5);
        if(_rand()<BOOST_PROB) h.speed += h.base*BOOST_GAIN;
        if(h.speed>h.base*1.12) h.fatigue=Math.min(1,h.fatigue+dt*FATIGUE_INC);
        else h.fatigue=Math.max(0,h.fatigue-dt*FATIGUE_DEC);
        h.speed -= h.fatigue*h.base*FATIGUE_PENALTY;
        const vMin=h.base*VMIN_RATIO, vMax=h.base*VMAX_RATIO;
        h.speed=clamp(h.speed,vMin,vMax);
        h.x += h.speed*dt*1.20;
        if(h.x>=dist){ h.x=dist; h.done=true; }    // 결승선에서 정확히 멈춤
        if(!h._finished && h.done){ h._finished=true; finishEntry(h); }
        placeHorseStraight(h);
      }
    }else if(mapMode==='sand'){
      const vb = $sandMap.getAttribute('viewBox').split(' ').map(Number);
      const W=vb[2], top=120, bot=380, mid=(top+bot)/2;
      const takeoffX = Math.round(W*0.4);
      const startX=80;
      const takeoffM = (takeoffX - startX)/20;

      for(const h of H){
        if(h.done) continue;

        if(!h.air && !h.landed){
          // 달리기(점프 길이와 독립)
          h.speed += h.base*JITTER_FACTOR*(_rand()-0.5);
          if(_rand()<BOOST_PROB) h.speed += h.base*BOOST_GAIN;
          if(h.speed>h.base*1.12) h.fatigue=Math.min(1,h.fatigue+dt*FATIGUE_INC);
          else h.fatigue=Math.max(0,h.fatigue-dt*FATIGUE_DEC);
          h.speed -= h.fatigue*h.base*FATIGUE_PENALTY;
          const vMin=h.base*VMIN_RATIO, vMax=h.base*VMAX_RATIO;
          h.speed=clamp(h.speed,vMin,vMax);
          h.x += h.speed*dt*1.20;

          if(h.x>=takeoffM && !h.air){
            h.air=true; h.airT=0; // 도약선에서 즉시 점프
          }
        }

        if(h.air){
          h.airT += dt;
          if(h.airT>=h.airDur){
            // 착지: 포물선 이후 모래 피트 내 위치
            h.air=false; h.landed=true;
            const jumpMeters = (h.jumpPow * (12 + _rand()*18)); // 12~30m 기본을 jumpPow로 가변
            h.landX = clamp(jumpMeters, 0, pitLen);
            h.x = takeoffM + h.landX; // 전체 진행 = 도약선 + 착지거리
            h.done = true;
            finishEntry(h);
          }
        }

        placeHorseSand(h);
      }
    }else if(mapMode==='arena'){
      const vb=$arenaMap.getAttribute('viewBox').split(' ').map(Number);
      const W=vb[2],Hvb=vb[3],cx=W/2,cy=Hvb/2;
      const R=320; // 경기장 반지름

      for(const h of H){
        if(h.done) continue;
        h.rot = (h.rot + 240*dt) % 360; // 회전 연출

        // 중앙을 축으로 도는 힘 + 약간의 노이즈
        const dx=h.ax-cx, dy=h.ay-cy, d=Math.hypot(dx,dy)||1;
        const tangential = {x: -dy/d, y: dx/d};
        const inward = {x: -dx/d, y: -dy/d};

        h.vx += tangential.x * 5 * dt + (Math.random()-0.5)*0.4;
        h.vy += tangential.y * 5 * dt + (Math.random()-0.5)*0.4;

        // 바깥으로 과하게 치우치면 안쪽으로 끌어당김(즉시 탈락 방지)
        if(d>R*0.75){
          h.vx += inward.x * 18 * dt;
          h.vy += inward.y * 18 * dt;
        }

        // 감쇠
        h.vx *= 0.996; h.vy *= 0.996;

        // 위치 갱신
        h.ax += h.vx; h.ay += h.vy;

        // 벽 충돌 체크: 벽을 치면 반발하고, 일정 속도 이상으로 바깥쪽이면 탈락
        const nd=Math.hypot(h.ax-cx,h.ay-cy);
        if(nd>R){
          const nx=(h.ax-cx)/nd, ny=(h.ay-cy)/nd;
          const dot = h.vx*nx + h.vy*ny;
          h.vx -= 1.8*dot*nx; h.vy -= 1.8*dot*ny; // 반사
          if(nd>R+14){
            h.done=true;
            if(!h._finished){ h._finished=true; finishEntry(h); }
          }else{
            h.ax = cx + nx*(R-2);
            h.ay = cy + ny*(R-2);
          }
        }
      }

      // 말-말 충돌로 밀치기
      for(let i=0;i<H.length;i++){
        for(let j=i+1;j<H.length;j++){
          const a=H[i], b=H[j];
          if(a.done||b.done) continue;
          const dx=b.ax-a.ax, dy=b.ay-a.ay, dd=dx*dx+dy*dy;
          const minD=22;
          if(dd<(minD*minD)){
            const d=Math.sqrt(dd)||1;
            const nx=dx/d, ny=dy/d;
            const push=1.2;
            a.vx -= nx*push; a.vy -= ny*push;
            b.vx += nx*push; b.vy += ny*push;
          }
        }
      }

      const alive = H.filter(x=>!x.done);
      if(alive.length===1 && !alive[0]._finished){
        alive[0].done=true; alive[0]._finished=true; finishEntry(alive[0]);
      }

      for(const h of H) placeHorseArena(h);
    }

    updateRanking();
    updateCamera();

    const allDone = (mapMode==='arena') ? (H.filter(h=>!h.done).length<=0) : H.every(h=>h.done);
    if(allDone){
      running=false;
    }else{
      raf=requestAnimationFrame(tick);
    }
  };

  raf=requestAnimationFrame(tick);
}

/* ====== Controls ====== */
document.getElementById('fullscreenBtn').onclick=()=>{
  const el=document.documentElement;
  if(!document.fullscreenElement){ el.requestFullscreen?.(); }
  else{ document.exitFullscreen?.(); }
};

document.getElementById('btnContact').onclick=()=>{
  alert("문의/건의/피드백: luckyhorserace@gmail.com\n언제든 자유롭게 의견 주세요!");
};

function updateMapVisibility(){
  $straightMap.style.display = (mapMode==='straight')?'block':'none';
  $ovalMap.style.display     = (mapMode==='oval')?'block':'none';
  $sandMap.style.display     = (mapMode==='sand')?'block':'none';
  $arenaMap.style.display    = (mapMode==='arena')?'block':'none';

  // 옵션 보이기/숨기기
  $raceDist.style.display = (mapMode==='straight')?'inline-block':'none';
  $raceLen.style.display  = (mapMode==='oval')?'inline-block':'none';
  $sandPit.style.display  = (mapMode==='sand')?'inline-block':'none';
}

$mapSel.onchange=()=>{
  mapMode = $mapSel.value;
  updateMapVisibility();

  if(raf) cancelAnimationFrame(raf);
  raf=null; running=false; pendingDraw={type:'first'}; drawFired=false; camPanX=0;
  $cele.style.display='none';
  clearHorses();
  resetFinishOrder();

  if(mapMode==='straight'){ drawStraight(); }
  if(mapMode==='oval'){ drawOval(); }
  if(mapMode==='sand'){ drawSand(); }
  if(mapMode==='arena'){ drawArena(); }
};

$leaderBtn.onclick=()=>{
  leaderView=!leaderView;
  $leaderBtn.textContent = `리더뷰: ${leaderView?'ON':'OFF'}`;
  if(!leaderView){ camPanX=0; $viewport.style.transform=`translate(-50%,-50%) scale(1)`; }
};

/* 추첨(라디오) */
const $drawNthInput = document.getElementById('drawNthInput');
document.getElementById('drawGroup').addEventListener('click',(e)=>{
  const lab = e.target.closest('label.seg-item');
  if(!lab) return;
  document.querySelectorAll('#drawGroup .seg-item').forEach(l=>l.classList.remove('on'));
  lab.classList.add('on');
  const type = lab.dataset.type;
  if(type==='first'){ pendingDraw={type:'first'}; $drawNthInput.disabled=true; }
  else if(type==='last'){ pendingDraw={type:'last'}; $drawNthInput.disabled=true; }
  else if(type==='nth'){ pendingDraw={type:'nth'}; $drawNthInput.disabled=false; $drawNthInput.focus(); }
});
$drawNthInput.addEventListener('input',()=>{
  const n = parseInt($drawNthInput.value,10);
  if(!Number.isFinite(n) || n<1){ pendingDraw=null; return; }
  pendingDraw={type:'nth', n};
});

/* 이름 입력 실시간 미리보기 */
$names.addEventListener('input', ()=>{
  const list=splitNames($names.value);
  if(!list.length){ clearHorses(); return; }
  buildHorses(list);
});

/* 시작/리셋 */
$start.onclick=async()=>{
  if(running) return;
  const list=splitNames($names.value);
  if(list.length<MIN){ alert('최소 2명 입력'); return; }
  if(list.length>MAX){ alert('최대 50명'); return; }

  laps=parseInt($raceLen.value,10)||3;
  dist=parseInt($raceDist.value,10)||100;
  pitLen=parseInt($sandPit.value,10)||50;

  seed=autoSeed(); reseed(seed);
  replay = {meta:{seed, names:list.map(x=>x.name), map:mapMode, dist, laps, pitLen, startedAt:Date.now()}, events:[]};

  $cele.style.display='none';
  if(raf) cancelAnimationFrame(raf);
  raf=null; running=false; camPanX=0;
  clearHorses();
  resetFinishOrder();

  if(mapMode==='straight'){ drawStraight(); }
  if(mapMode==='oval'){ drawOval(); }
  if(mapMode==='sand'){ drawSand(); }
  if(mapMode==='arena'){ drawArena(); }

  buildHorses(list);
  await countdown();
  run();
};

$reset.onclick=()=>{
  if(raf) cancelAnimationFrame(raf);
  raf=null; running=false; pendingDraw={type:'first'}; drawFired=false; camPanX=0;
  $cele.style.display='none';
  clearHorses();
  resetFinishOrder();

  if(mapMode==='straight'){ drawStraight(); }
  if(mapMode==='oval'){ drawOval(); }
  if(mapMode==='sand'){ drawSand(); }
  if(mapMode==='arena'){ drawArena(); }

  // 라디오 UI 초기화 (1등 선택)
  document.querySelectorAll('#drawGroup .seg-item').forEach(l=>l.classList.remove('on'));
  document.querySelector('#drawGroup .seg-item[data-type="first"]').classList.add('on');
  $drawNthInput.value=''; $drawNthInput.disabled=true;
};

/* 배치/리사이즈 */
addEventListener('resize', ()=>{
  if(mapMode==='straight') drawStraight();
  if(mapMode==='oval') drawOval();
  if(mapMode==='sand') drawSand();
  if(mapMode==='arena') drawArena();
  H.forEach(placeEntity);
  updateCamera();
});

/* ====== 초기 진입 기본값 ====== */
mapMode='straight';
updateMapVisibility();
drawStraight();
document.querySelector('#drawGroup .seg-item[data-type="first"]').classList.add('on');
$leaderBtn.textContent='리더뷰: ON';
</script>
</body>
</html>
